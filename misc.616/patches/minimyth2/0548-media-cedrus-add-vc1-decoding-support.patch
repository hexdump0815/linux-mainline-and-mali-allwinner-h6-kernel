
media: Add VC-1 parsed slice
media: cedrus: Add VC-1 support
media: vc1 hacks

Signed-off-by: Jernej Skrabec <jernej.skrabec@gmail.com>

code from: https://github.com/jernejsk/linux-1/commits/vc1

milion thx Jernej!

diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-core.c linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-core.c
--- linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-core.c	2022-11-27 22:31:48.000000000 +0100
+++ linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-core.c	2022-11-30 21:45:07.156628969 +0100
@@ -350,6 +350,12 @@
 	case V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS:
 		pr_cont("HEVC_DECODE_PARAMS");
 		break;
+	case V4L2_CTRL_TYPE_VC1_SLICE_PARAMS:
+		pr_cont("VC1_SLICE_PARAMS");
+		break;
+	case V4L2_CTRL_TYPE_VC1_BITPLANES:
+		pr_cont("VC1_BITPLANES");
+		break;
 	default:
 		pr_cont("unknown type %d", ctrl->type);
 		break;
@@ -918,6 +924,10 @@
 			return -EINVAL;
 		break;
 
+	case V4L2_CTRL_TYPE_VC1_SLICE_PARAMS:
+	case V4L2_CTRL_TYPE_VC1_BITPLANES:
+		break;
+
 	default:
 		return -EINVAL;
 	}
@@ -1605,6 +1615,12 @@
 	case V4L2_CTRL_TYPE_AREA:
 		elem_size = sizeof(struct v4l2_area);
 		break;
+	case V4L2_CTRL_TYPE_VC1_SLICE_PARAMS:
+		elem_size = sizeof(struct v4l2_ctrl_vc1_slice_params);
+		break;
+	case V4L2_CTRL_TYPE_VC1_BITPLANES:
+		elem_size = sizeof(struct v4l2_ctrl_vc1_bitplanes);
+		break;
 	default:
 		if (type < V4L2_CTRL_COMPOUND_TYPES)
 			elem_size = sizeof(s32);
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-defs.c linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-defs.c
--- linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-defs.c	2022-11-27 22:31:48.000000000 +0100
+++ linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ctrls-defs.c	2022-11-30 21:45:07.156628969 +0100
@@ -1189,6 +1189,8 @@
 	case V4L2_CID_STATELESS_AV1_TILE_GROUP_ENTRY:		return "AV1 Tile Group Entry";
 	case V4L2_CID_STATELESS_AV1_FRAME:			return "AV1 Frame Parameters";
 	case V4L2_CID_STATELESS_AV1_FILM_GRAIN:			return "AV1 Film Grain";
+	case V4L2_CID_STATELESS_VC1_SLICE_PARAMS:		return "VC1 Slice Parameters";
+	case V4L2_CID_STATELESS_VC1_BITPLANES:			return "VC1 Bitplanes";
 
 	/* Colorimetry controls */
 	/* Keep the order of the 'case's the same as in v4l2-controls.h! */
@@ -1539,6 +1541,12 @@
 	case V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY:
 		*type = V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY;
 		break;
+	case V4L2_CID_STATELESS_VC1_SLICE_PARAMS:
+		*type = V4L2_CTRL_TYPE_VC1_SLICE_PARAMS;
+		break;
+	case V4L2_CID_STATELESS_VC1_BITPLANES:
+		*type = V4L2_CTRL_TYPE_VC1_BITPLANES;
+		break;
 	default:
 		*type = V4L2_CTRL_TYPE_INTEGER;
 		break;
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ioctl.c linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ioctl.c
--- linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ioctl.c	2022-11-30 21:46:34.426627394 +0100
+++ linux-6.1-rc7/drivers/media/v4l2-core/v4l2-ioctl.c	2022-11-30 21:45:07.156628969 +0100
@@ -1473,6 +1473,7 @@
 		case V4L2_PIX_FMT_XVID:		descr = "Xvid"; break;
 		case V4L2_PIX_FMT_VC1_ANNEX_G:	descr = "VC-1 (SMPTE 412M Annex G)"; break;
 		case V4L2_PIX_FMT_VC1_ANNEX_L:	descr = "VC-1 (SMPTE 412M Annex L)"; break;
+		case V4L2_PIX_FMT_VC1_SLICE:	descr = "VC-1 Parsed Data"; break;
 		case V4L2_PIX_FMT_VP8:		descr = "VP8"; break;
 		case V4L2_PIX_FMT_VP8_FRAME:    descr = "VP8 Frame"; break;
 		case V4L2_PIX_FMT_VP9:		descr = "VP9"; break;
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.c linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.c
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.c	2022-11-30 21:46:33.296627414 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.c	2022-11-30 21:45:13.036628862 +0100
@@ -248,6 +248,18 @@
 		},
 		.capabilities	= CEDRUS_CAPABILITY_H265_DEC,
 	},
+	{
+		.cfg = {
+			.id	= V4L2_CID_STATELESS_VC1_SLICE_PARAMS,
+		},
+		.capabilities	= CEDRUS_CAPABILITY_VC1_DEC,
+	},
+	{
+		.cfg = {
+			.id	= V4L2_CID_STATELESS_VC1_BITPLANES,
+		},
+		.capabilities	= CEDRUS_CAPABILITY_VC1_DEC,
+	},
 };
 
 #define CEDRUS_CONTROLS_COUNT	ARRAY_SIZE(cedrus_controls)
@@ -601,7 +613,8 @@
 			  CEDRUS_CAPABILITY_MPEG2_DEC |
 			  CEDRUS_CAPABILITY_H264_DEC |
 			  CEDRUS_CAPABILITY_H265_DEC |
-			  CEDRUS_CAPABILITY_VP8_DEC,
+			  CEDRUS_CAPABILITY_VP8_DEC |
+			  CEDRUS_CAPABILITY_VC1_DEC,
 	.mod_rate	= 402000000,
 };
 
@@ -615,7 +628,8 @@
 	.capabilities	= CEDRUS_CAPABILITY_UNTILED |
 			  CEDRUS_CAPABILITY_MPEG2_DEC |
 			  CEDRUS_CAPABILITY_H264_DEC |
-			  CEDRUS_CAPABILITY_VP8_DEC,
+			  CEDRUS_CAPABILITY_VP8_DEC |
+			  CEDRUS_CAPABILITY_VC1_DEC,
 	.mod_rate	= 297000000,
 };
 
@@ -632,7 +646,8 @@
 			  CEDRUS_CAPABILITY_MPEG2_DEC |
 			  CEDRUS_CAPABILITY_H264_DEC |
 			  CEDRUS_CAPABILITY_H265_DEC |
-			  CEDRUS_CAPABILITY_VP8_DEC,
+			  CEDRUS_CAPABILITY_VP8_DEC |
+			  CEDRUS_CAPABILITY_VC1_DEC,
 	.mod_rate	= 402000000,
 };
 
@@ -641,7 +656,8 @@
 			  CEDRUS_CAPABILITY_MPEG2_DEC |
 			  CEDRUS_CAPABILITY_H264_DEC |
 			  CEDRUS_CAPABILITY_H265_DEC |
-			  CEDRUS_CAPABILITY_VP8_DEC,
+			  CEDRUS_CAPABILITY_VP8_DEC |
+			  CEDRUS_CAPABILITY_VC1_DEC,
 	.mod_rate	= 402000000,
 };
 
@@ -651,7 +667,8 @@
 			  CEDRUS_CAPABILITY_H264_DEC |
 			  CEDRUS_CAPABILITY_H265_DEC |
 			  CEDRUS_CAPABILITY_H265_10_DEC |
-			  CEDRUS_CAPABILITY_VP8_DEC,
+			  CEDRUS_CAPABILITY_VP8_DEC |
+			  CEDRUS_CAPABILITY_VC1_DEC,
 	.mod_rate	= 600000000,
 };
 
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_dec.c linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_dec.c
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_dec.c	2022-11-30 21:46:32.356627431 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_dec.c	2022-11-30 21:45:13.036628862 +0100
@@ -86,6 +86,13 @@
 			V4L2_CID_STATELESS_VP8_FRAME);
 		break;
 
+	case V4L2_PIX_FMT_VC1_SLICE:
+		run.vc1.slice_params = cedrus_find_control_data(ctx,
+			V4L2_CID_STATELESS_VC1_SLICE_PARAMS);
+		run.vc1.bitplanes = cedrus_find_control_data(ctx,
+			V4L2_CID_STATELESS_VC1_BITPLANES);
+		break;
+
 	default:
 		break;
 	}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.h linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.h
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.h	2022-11-30 21:46:32.493294095 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus.h	2022-12-02 10:32:05.366600075 +0100
@@ -34,6 +34,7 @@
 #define CEDRUS_CAPABILITY_MPEG2_DEC	BIT(3)
 #define CEDRUS_CAPABILITY_VP8_DEC	BIT(4)
 #define CEDRUS_CAPABILITY_H265_10_DEC	BIT(5)
+#define CEDRUS_CAPABILITY_VC1_DEC	BIT(6)
 
 enum cedrus_irq_status {
 	CEDRUS_IRQ_NONE,
@@ -81,6 +82,11 @@
 	const struct v4l2_ctrl_vp8_frame		*frame_params;
 };
 
+struct cedrus_vc1_run {
+	const struct v4l2_ctrl_vc1_slice_params		*slice_params;
+	const struct v4l2_ctrl_vc1_bitplanes		*bitplanes;
+};
+
 struct cedrus_run {
 	struct vb2_v4l2_buffer	*src;
 	struct vb2_v4l2_buffer	*dst;
@@ -90,6 +96,7 @@
 		struct cedrus_mpeg2_run	mpeg2;
 		struct cedrus_h265_run	h265;
 		struct cedrus_vp8_run	vp8;
+		struct cedrus_vc1_run	vc1;
 	};
 };
 
@@ -109,6 +116,12 @@
 			dma_addr_t	mv_col_buf_dma;
 			ssize_t		mv_col_buf_size;
 		} h265;
+		struct {
+			bool		interlaced;
+			bool		rangeredfrm;
+			unsigned int	ptype;
+			int		compen;
+		} vc1;
 	} codec;
 };
 
@@ -152,6 +165,14 @@
 			u8		*entropy_probs_buf;
 			dma_addr_t	entropy_probs_buf_dma;
 		} vp8;
+		struct {
+			void		*mv_buf;
+			dma_addr_t	mv_buf_addr;
+			void		*acdc_buf;
+			dma_addr_t	acdc_buf_addr;
+			u8		*bitplanes_buf;
+			dma_addr_t	bitplanes_buf_addr;
+		} vc1;
 	} codec;
 };
 
@@ -201,6 +222,7 @@
 extern struct cedrus_dec_ops cedrus_dec_ops_h264;
 extern struct cedrus_dec_ops cedrus_dec_ops_h265;
 extern struct cedrus_dec_ops cedrus_dec_ops_vp8;
+extern struct cedrus_dec_ops cedrus_dec_ops_vc1;
 
 static inline void cedrus_write(struct cedrus_dev *dev, u32 reg, u32 val)
 {
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_hw.c linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_hw.c
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_hw.c	2022-11-30 21:46:32.383294098 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_hw.c	2022-11-30 21:45:13.036628862 +0100
@@ -57,6 +57,10 @@
 		reg |= VE_MODE_DEC_H265;
 		break;
 
+	case V4L2_PIX_FMT_VC1_SLICE:
+		reg |= VE_MODE_DEC_VC1;
+		break;
+
 	default:
 		return -EINVAL;
 	}
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_regs.h linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_regs.h
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_regs.h	2022-11-30 21:46:32.493294095 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_regs.h	2022-12-02 10:32:05.366600075 +0100
@@ -31,6 +31,7 @@
 
 #define VE_ENGINE_DEC_MPEG			0x100
 #define VE_ENGINE_DEC_H264			0x200
+#define VE_ENGINE_DEC_VC1			0x300
 #define VE_ENGINE_DEC_H265			0x500
 
 #define VE_MODE					0x00
@@ -43,6 +44,7 @@
 #define VE_MODE_DDR_MODE_BW_256			(0x02 << 16)
 #define VE_MODE_DISABLED			(0x07 << 0)
 #define VE_MODE_DEC_H265			(0x04 << 0)
+#define VE_MODE_DEC_VC1				(0x02 << 0)
 #define VE_MODE_DEC_H264			(0x01 << 0)
 #define VE_MODE_DEC_MPEG			(0x00 << 0)
 
@@ -540,6 +542,154 @@
 #define VE_DEC_H265_SRAM_DATA_ADDR_BASE(a)	((a) >> 8)
 #define VE_DEC_H265_SRAM_REF_PIC_LIST_LT_REF	BIT(7)
 
+#define VE_DEC_VC1_EPHS				(VE_ENGINE_DEC_VC1 + 0x00)
+#define VE_DEC_VC1_EPHS_STARTCODE_DET_EN	BIT(16)
+#define VE_DEC_VC1_EPHS_EPTB_DET_BYPASS		BIT(15)
+#define VE_DEC_VC1_EPHS_SYNCMARKER		BIT(14)
+#define VE_DEC_VC1_EPHS_FINTERPFLAG		BIT(13)
+#define VE_DEC_VC1_EPHS_RANGERED		BIT(12)
+#define VE_DEC_VC1_EPHS_QUANTIZER(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_EPHS_OVERLAP			BIT(9)
+#define VE_DEC_VC1_EPHS_VSTRANSFORM		BIT(8)
+#define VE_DEC_VC1_EPHS_DQUANT(x)		SHIFT_AND_MASK_BITS(x, 7, 6)
+#define VE_DEC_VC1_EPHS_EXTENDEDMV		BIT(5)
+#define VE_DEC_VC1_EPHS_FASTUVMC		BIT(4)
+#define VE_DEC_VC1_EPHS_MULTIRES		BIT(3)
+#define VE_DEC_VC1_EPHS_LOOPFILTER		BIT(2)
+#define VE_DEC_VC1_EPHS_PROFILE(x)		SHIFT_AND_MASK_BITS(x, 1, 0)
+
+#define VE_DEC_VC1_PICCTRL			(VE_ENGINE_DEC_VC1 + 0x04)
+#define VE_DEC_VC1_PICCTRL_BITPL_CODING		BIT(31)
+#define VE_DEC_VC1_PICCTRL_DIRECT_REF_INTRA	BIT(29)
+#define VE_DEC_VC1_PICCTRL_DIRECTMB_RAW		BIT(28)
+#define VE_DEC_VC1_PICCTRL_TTFRM(x)		SHIFT_AND_MASK_BITS(x, 27, 26)
+#define VE_DEC_VC1_PICCTRL_TTMBF		BIT(25)
+#define VE_DEC_VC1_PICCTRL_SKIPMB_RAW		BIT(24)
+#define VE_DEC_VC1_PICCTRL_CBPTAB(x)		SHIFT_AND_MASK_BITS(x, 23, 22)
+#define VE_DEC_VC1_PICCTRL_OVERFLAGS_RAW	BIT(21)
+#define VE_DEC_VC1_PICCTRL_ACPRED_RAW		BIT(20)
+#define VE_DEC_VC1_PICCTRL_CONDOVER(x)		SHIFT_AND_MASK_BITS(x, 19, 18)
+#define VE_DEC_VC1_PICCTRL_RNDCTRL		BIT(17)
+#define VE_DEC_VC1_PICCTRL_TRANSDCTAB		BIT(16)
+#define VE_DEC_VC1_PICCTRL_TRANSACFRM2(x)	SHIFT_AND_MASK_BITS(x, 15, 14)
+#define VE_DEC_VC1_PICCTRL_TRANSACFRM(x)	SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICCTRL_BWD_RANGEREDFRM	BIT(10)
+#define VE_DEC_VC1_PICCTRL_FWD_RANGEREDFRM	BIT(9)
+#define VE_DEC_VC1_PICCTRL_RANGEREDFRM		BIT(8)
+#define VE_DEC_VC1_PICCTRL_SECOND_FIELD		BIT(7)
+#define VE_DEC_VC1_PICCTRL_BOTTOM_FIELD		BIT(6)
+#define VE_DEC_VC1_PICCTRL_FCM(x)		SHIFT_AND_MASK_BITS(x, 5, 4)
+#define VE_DEC_VC1_PICCTRL_PTYPE(x)		SHIFT_AND_MASK_BITS(x, 2, 0)
+
+#define VE_DEC_VC1_PICQP			(VE_ENGINE_DEC_VC1 + 0x08)
+#define VE_DEC_VC1_PICQP_DQBILEVEL		BIT(25)
+#define VE_DEC_VC1_PICQP_DQUANTFRM		BIT(24)
+#define VE_DEC_VC1_PICQP_ALTPQUANT(x)		SHIFT_AND_MASK_BITS(x, 20, 16)
+#define VE_DEC_VC1_PICQP_DQDBEDGE(x)		SHIFT_AND_MASK_BITS(x, 15, 13)
+#define VE_DEC_VC1_PICQP_DQSBEDGE(x)		SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICQP_DQPPROFILE(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_PICQP_PQUANTIZER		BIT(9)
+#define VE_DEC_VC1_PICQP_HALFQP			BIT(8)
+#define VE_DEC_VC1_PICQP_PQINDEX(x)		SHIFT_AND_MASK_BITS(x, 4, 0)
+
+#define VE_DEC_VC1_PICMV			(VE_ENGINE_DEC_VC1 + 0x0c)
+#define VE_DEC_VC1_PICMV_MVTYPEMB_RAW		BIT(20)
+#define VE_DEC_VC1_PICMV_MVTAB(x)		SHIFT_AND_MASK_BITS(x, 17, 16)
+#define VE_DEC_VC1_PICMV_INTENSITY_COMP_EN	BIT(14)
+#define VE_DEC_VC1_PICMV_MVMODE(x)		SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICMV_MVRANGE(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_PICMV_BFRAC_LESS_THAN_HALF	BIT(9)
+#define VE_DEC_VC1_PICMV_BFRACTION(x)		SHIFT_AND_MASK_BITS(x, 7, 0)
+
+#define VE_DEC_VC1_PICINTENCOMP			(VE_ENGINE_DEC_VC1 + 0x10)
+#define VE_DEC_VC1_PICINTENCOMP_FIELD(x)	SHIFT_AND_MASK_BITS(x, 31, 30)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(x)	SHIFT_AND_MASK_BITS(x, 29, 24)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASCALE2(x)	SHIFT_AND_MASK_BITS(x, 21, 16)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASHIFT1(x)	SHIFT_AND_MASK_BITS(x, 13, 8)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(x)	SHIFT_AND_MASK_BITS(x, 5, 0)
+
+#define VE_DEC_VC1_PICINTERLACE			(VE_ENGINE_DEC_VC1 + 0x14)
+#define VE_DEC_VC1_PICINTERLACE_NUMREF		BIT(31)
+#define VE_DEC_VC1_PICINTERLACE_BWD_INTERLACE	BIT(30)
+#define VE_DEC_VC1_PICINTERLACE_FWD_INTERLACE	BIT(29)
+#define VE_DEC_VC1_PICINTERLACE_FORWARD_RAW	BIT(28)
+#define VE_DEC_VC1_PICINTERLACE_INTENCOMPFLD(x)	SHIFT_AND_MASK_BITS(x, 27, 26)
+#define VE_DEC_VC1_PICINTERLACE_REFFIELD	BIT(25)
+#define VE_DEC_VC1_PICINTERLACE_BRFD(x)		SHIFT_AND_MASK_BITS(x, 23, 22)
+#define VE_DEC_VC1_PICINTERLACE_FRFD(x)		SHIFT_AND_MASK_BITS(x, 21, 20)
+#define VE_DEC_VC1_PICINTERLACE_4MVBPTAB(x)	SHIFT_AND_MASK_BITS(x, 19, 18)
+#define VE_DEC_VC1_PICINTERLACE_2MVBPTAB(x)	SHIFT_AND_MASK_BITS(x, 17, 16)
+#define VE_DEC_VC1_PICINTERLACE_INTENCOMP	BIT(15)
+#define VE_DEC_VC1_PICINTERLACE_ICBPTAB(x)	SHIFT_AND_MASK_BITS(x, 14, 12)
+#define VE_DEC_VC1_PICINTERLACE_IMVTAB(x)	SHIFT_AND_MASK_BITS(x, 10, 8)
+#define VE_DEC_VC1_PICINTERLACE_MBMODETAB(x)	SHIFT_AND_MASK_BITS(x, 6, 4)
+#define VE_DEC_VC1_PICINTERLACE_4MVSWITCH	BIT(3)
+#define VE_DEC_VC1_PICINTERLACE_DMVRANGE(x)	SHIFT_AND_MASK_BITS(x, 2, 1)
+#define VE_DEC_VC1_PICINTERLACE_FIELDTX_RAW	BIT(0)
+
+#define VE_DEC_VC1_PICHDRLEN			(VE_ENGINE_DEC_VC1 + 0x18)
+#define VE_DEC_VC1_PICHDRLEN_LENGTH(l)		SHIFT_AND_MASK_BITS(l, 15, 0)
+
+#define VE_DEC_VC1_FSIZE			(VE_ENGINE_DEC_VC1 + 0x1c)
+#define VE_DEC_VC1_FSIZE_WIDTH(w) \
+	SHIFT_AND_MASK_BITS(DIV_ROUND_UP(w, 16), 15, 8)
+#define VE_DEC_VC1_FSIZE_HEIGHT(h) \
+	SHIFT_AND_MASK_BITS(DIV_ROUND_UP(h, 16), 7, 0)
+
+#define VE_DEC_VC1_PICSIZE			(VE_ENGINE_DEC_VC1 + 0x20)
+#define VE_DEC_VC1_PICSIZE_WIDTH(w)		SHIFT_AND_MASK_BITS(w, 27, 16)
+#define VE_DEC_VC1_PICSIZE_HEIGHT(h)		SHIFT_AND_MASK_BITS(h, 11, 0)
+
+#define VE_DEC_VC1_CTRL				(VE_ENGINE_DEC_VC1 + 0x24)
+#define VE_DEC_VC1_CTRL_EPTB_DET_BYPASS		BIT(24)
+#define VE_DEC_VC1_CTRL_MCRI_CACHE_EN		BIT(10)
+#define VE_DEC_VC1_CTRL_WRITE_ROTATE_PIC	BIT(9)
+#define VE_DEC_VC1_CTRL_NO_RECONSTRUCT_PIC	BIT(8)
+#define VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN	BIT(2)
+#define VE_DEC_VC1_CTRL_ERROR_IRQ_EN		BIT(1)
+#define VE_DEC_VC1_CTRL_FINISH_IRQ_EN		BIT(0)
+#define VE_DEC_VC1_CTRL_IRQ_MASK \
+	(VE_DEC_VC1_CTRL_FINISH_IRQ_EN | VE_DEC_VC1_CTRL_ERROR_IRQ_EN | \
+	 VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN)
+
+#define VE_DEC_VC1_TRIGGER_TYPE			(VE_ENGINE_DEC_VC1 + 0x28)
+#define VE_DEC_VC1_TRIGGER_TYPE_N_BITS(n)	SHIFT_AND_MASK_BITS(n, 13, 8)
+#define VE_DEC_VC1_TRIGGER_TYPE_DECODE		(8 << 0)
+#define VE_DEC_VC1_TRIGGER_TYPE_INIT_SWDEC	(7 << 0)
+#define VE_DEC_VC1_TRIGGER_TYPE_FLUSH_BITS	(3 << 0)
+#define VE_DEC_VC1_TRIGGER_TYPE_GET_BITS	(2 << 0)
+
+#define VE_DEC_VC1_STATUS			(VE_ENGINE_DEC_VC1 + 0x2c)
+#define VE_DEC_VC1_STATUS_BITS_BUSY		BIT(22)
+#define VE_DEC_VC1_STATUS_VLD_DATA_REQ		BIT(2)
+#define VE_DEC_VC1_STATUS_ERROR			BIT(1)
+#define VE_DEC_VC1_STATUS_SUCCESS		BIT(0)
+#define VE_DEC_VC1_STATUS_INT_MASK		VE_DEC_VC1_CTRL_IRQ_MASK
+
+#define VE_DEC_VC1_BITS_ADDR			(VE_ENGINE_DEC_VC1 + 0x30)
+#define VE_DEC_VC1_BITS_ADDR_FIRST_SLICE_DATA	BIT(30)
+#define VE_DEC_VC1_BITS_ADDR_LAST_SLICE_DATA	BIT(29)
+#define VE_DEC_VC1_BITS_ADDR_VALID_SLICE_DATA	BIT(28)
+#define VE_DEC_VC1_BITS_ADDR_BASE(x)		(((x) & 0x0ffffff0) | ((x) >> 28))
+
+#define VE_DEC_VC1_BITS_OFFSET			(VE_ENGINE_DEC_VC1 + 0x34)
+#define VE_DEC_VC1_BITS_LEN			(VE_ENGINE_DEC_VC1 + 0x38)
+#define VE_DEC_VC1_BITS_END_ADDR		(VE_ENGINE_DEC_VC1 + 0x3c)
+#define VE_DEC_VC1_REC_LUMA			(VE_ENGINE_DEC_VC1 + 0x40)
+#define VE_DEC_VC1_REC_CHROMA			(VE_ENGINE_DEC_VC1 + 0x44)
+#define VE_DEC_VC1_FWD_REF_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x48)
+#define VE_DEC_VC1_FWD_REF_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x4c)
+#define VE_DEC_VC1_BWD_REF_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x50)
+#define VE_DEC_VC1_BWD_REF_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x54)
+
+#define VE_DEC_VC1_DCACPRED_ADDR		(VE_ENGINE_DEC_VC1 + 0x5c)
+#define VE_DEC_VC1_BITPLANE_ADDR		(VE_ENGINE_DEC_VC1 + 0x60)
+#define VE_DEC_VC1_MVINFO_ADDR			(VE_ENGINE_DEC_VC1 + 0x64)
+
+#define VE_DEC_VC1_ROT_CTRL			(VE_ENGINE_DEC_VC1 + 0xc0)
+#define VE_DEC_VC1_ROT_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0xc4)
+#define VE_DEC_VC1_ROT_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0xc8)
+
 #define VE_H264_SPS			0x200
 #define VE_H264_SPS_MBS_ONLY			BIT(18)
 #define VE_H264_SPS_MB_ADAPTIVE_FRAME_FIELD	BIT(17)
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c	2022-12-02 10:32:05.366600075 +0100
@@ -0,0 +1,724 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Cedrus VPU driver
+ *
+ * Copyright (c) 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+
+#include <media/videobuf2-dma-contig.h>
+
+#include "cedrus.h"
+#include "cedrus_hw.h"
+#include "cedrus_regs.h"
+
+#define MV_BUF_SIZE			(64 * SZ_1K)
+#define ACDC_BUF_SIZE			(16 * SZ_1K)
+#define BITPLANES_BUF_SIZE		(16 * SZ_1K)
+
+#define VC1_PROFILE_SIMPLE		0
+#define VC1_PROFILE_MAIN		1
+#define VC1_PROFILE_COMPLEX		2
+#define VC1_PROFILE_ADVANCED		3
+
+#define VC1_PICTURE_TYPE_I		0
+#define VC1_PICTURE_TYPE_P		1
+#define VC1_PICTURE_TYPE_B		2
+#define VC1_PICTURE_TYPE_BI		3
+#define VC1_PICTURE_TYPE_SKIPPED	4
+
+#define VC1_FCM_PROGRESSIVE		0
+#define VC1_FCM_INTERLACED_FRAME	1
+#define VC1_FCM_INTERLACED_FIELD	2
+
+#define VC1_MVMODE_1MV_HPEL_BILIN	0
+#define VC1_MVMODE_1MV			1
+#define VC1_MVMODE_1MV_HPEL		2
+#define VC1_MVMODE_MIXED_MV		3
+#define VC1_MVMODE_INTENSITY_COMP	4
+
+#define VC1_CONDOVER_NONE		0
+#define VC1_CONDOVER_ALL		1
+#define VC1_CONDOVER_SELECT		2
+
+#define VC1_QUANT_FRAME_IMPLICIT	0
+#define VC1_QUANT_FRAME_EXPLICIT	1
+#define VC1_QUANT_NON_UNIFORM		2
+#define VC1_QUANT_UNIFORM		3
+
+#define VC1_BITPLANE_OFFSET_ACPRED	0x0000
+#define VC1_BITPLANE_OFFSET_OVERFLAGS	0x0400
+#define VC1_BITPLANE_OFFSET_MVTYPEMB	0x0800
+#define VC1_BITPLANE_OFFSET_SKIPMB	0x0C00
+#define VC1_BITPLANE_OFFSET_DIRECTMB	0x1000
+#define VC1_BITPLANE_OFFSET_FIELDTX	0x1400
+#define VC1_BITPLANE_OFFSET_FORWARDMB	0x1800
+
+#define FRACTION(num, denom) (((num) * 256) / (denom))
+
+static const unsigned int vc1_fractions[] = {
+	FRACTION(1, 2),
+	FRACTION(1, 3),
+	FRACTION(2, 3),
+	FRACTION(1, 4),
+	FRACTION(3, 4),
+	FRACTION(1, 5),
+	FRACTION(2, 5),
+	FRACTION(3, 5),
+	FRACTION(4, 5),
+	FRACTION(1, 6),
+	FRACTION(5, 6),
+	FRACTION(1, 7),
+	FRACTION(2, 7),
+	FRACTION(3, 7),
+	FRACTION(4, 7),
+	FRACTION(5, 7),
+	FRACTION(6, 7),
+	FRACTION(1, 8),
+	FRACTION(3, 8),
+	FRACTION(5, 8),
+	FRACTION(7, 8),
+};
+
+const uint8_t ff_vc1_pquant_table[3][32] = {
+    /* Implicit quantizer */
+    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  6,  7,  8,  9, 10, 11, 12,
+      13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 29, 31 },
+    /* Explicit quantizer, pquantizer uniform */
+    {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 },
+};
+
+static const unsigned int vc1_mvmode_map[] = {3, 0, 2, 1};
+
+static unsigned int cedrus_vc1_get_fraction(unsigned int index)
+{
+	if (index >= ARRAY_SIZE(vc1_fractions))
+		return FRACTION(7, 8);
+
+	return vc1_fractions[index];
+}
+
+static unsigned int cedrus_vc1_get_pq(unsigned int pqindex, unsigned int qmode)
+{
+	if (qmode == VC1_QUANT_FRAME_IMPLICIT)
+		return ff_vc1_pquant_table[0][pqindex];
+	else
+		return ff_vc1_pquant_table[1][pqindex];
+}
+static unsigned int seq;
+static void cedrus_vc1_bitplanes_setup(struct cedrus_ctx *ctx,
+				       struct cedrus_run *run)
+{
+	const struct v4l2_vc1_entrypoint_header *entrypoint;
+	const struct v4l2_ctrl_vc1_bitplanes *bitplanes;
+	unsigned int mb_num, plane_size;
+
+	entrypoint = &run->vc1.slice_params->entrypoint_header;
+	bitplanes = run->vc1.bitplanes;
+
+	/*
+	 * FIXME: Not sure if max coded size or current code
+	 * size is correct.
+	 */
+	mb_num = DIV_ROUND_UP(entrypoint->coded_width, 16) *
+		 DIV_ROUND_UP(entrypoint->coded_height, 16);
+	plane_size = DIV_ROUND_UP(mb_num, 8);
+
+	/*if (plane_size > 1024) {
+		printk("VC-1: Warning, bitplane size too big!\n");
+		plane_size = 1024;
+	}*/
+
+	plane_size = 1024;
+
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_MVTYPEMB) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_MVTYPEMB,
+		       bitplanes->mvtypemb, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_MVTYPEMB + 7 * SZ_1K,
+		       bitplanes->mvtypemb + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_DIRECTMB) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_DIRECTMB,
+		       bitplanes->directmb, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_DIRECTMB + 7 * SZ_1K,
+		       bitplanes->directmb + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_SKIPMB) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_SKIPMB,
+		       bitplanes->skipmb, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_SKIPMB + 7 * SZ_1K,
+		       bitplanes->skipmb + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_FIELDTX) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FIELDTX,
+		       bitplanes->fieldtx, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FIELDTX + 7 * SZ_1K,
+		       bitplanes->fieldtx + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_FORWARDMB) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FORWARDMB,
+		       bitplanes->forwardmb, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FORWARDMB + 7 * SZ_1K,
+		       bitplanes->forwardmb + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_ACPRED) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_ACPRED,
+		       bitplanes->acpred, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_ACPRED + 7 * SZ_1K,
+		       bitplanes->acpred + 1024, plane_size);
+	}
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_OVERFLAGS) {
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_OVERFLAGS,
+		       bitplanes->overflags, plane_size);
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_OVERFLAGS + 7 * SZ_1K,
+		       bitplanes->overflags + 1024, plane_size);
+	}
+}
+
+static enum cedrus_irq_status
+cedrus_vc1_irq_status(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	u32 reg = cedrus_read(dev, VE_DEC_VC1_STATUS);
+
+	if (reg & (VE_DEC_VC1_STATUS_ERROR |
+		   VE_DEC_VC1_STATUS_VLD_DATA_REQ))
+		return CEDRUS_IRQ_ERROR;
+
+	if (reg & VE_DEC_VC1_STATUS_SUCCESS)
+		return CEDRUS_IRQ_OK;
+
+	return CEDRUS_IRQ_NONE;
+}
+
+static void cedrus_vc1_irq_clear(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+
+	cedrus_write(dev, VE_DEC_VC1_STATUS,
+		     VE_DEC_VC1_STATUS_INT_MASK);
+}
+
+static void cedrus_vc1_irq_disable(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	u32 reg = cedrus_read(dev, VE_DEC_VC1_CTRL);
+
+	cedrus_write(dev, VE_DEC_VC1_CTRL,
+		     reg & ~VE_DEC_VC1_CTRL_IRQ_MASK);
+}
+
+static const unsigned int vc1_dmvrange_map[] = {0, 2, 1, 3};
+static u32 oldval;
+static int intenen;
+static u32 vc1_icb1_regbak, vc1_icb0_reg68, vc1_icf0_reg6c;
+
+static int cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
+{
+	bool interlaced, top_field_first, second_field, ref_field, rangeredfrm;
+	const struct v4l2_ctrl_vc1_slice_params *slice = run->vc1.slice_params;
+	const struct v4l2_ctrl_vc1_bitplanes *bitplanes = run->vc1.bitplanes;
+	const struct v4l2_vc1_entrypoint_header *entrypoint;
+	struct cedrus_buffer *fwd_buf, *bwd_buf, *out_buf;
+	struct vb2_buffer *src_buf = &run->src->vb2_buf;
+	const struct v4l2_vc1_picture_layer *picture;
+	const struct v4l2_vc1_vopdquant *vopdquant;
+	dma_addr_t dst_luma_addr, dst_chroma_addr;
+	const struct v4l2_vc1_sequence *sequence;
+	const struct v4l2_vc1_metadata *metadata;
+	unsigned int bfraction, frfd, mvmode;
+	struct cedrus_dev *dev = ctx->dev;
+	struct vb2_buffer *backward_vb2;
+	struct vb2_buffer *forward_vb2;
+	dma_addr_t src_buf_addr;
+	u32 reg, condover, pq;
+	struct vb2_queue *vq;
+	size_t slice_bytes;
+	int brfd, flag;
+
+	unsigned int raw_coding = slice->raw_coding_flags;
+	//printk("%d raw coding: %.2x, flags: %.2x\n", seq + 1, slice->raw_coding_flags, bitplanes->bitplane_flags);
+	raw_coding = ~bitplanes->bitplane_flags;
+
+	sequence = &slice->sequence;
+	entrypoint = &slice->entrypoint_header;
+	picture = &slice->picture_layer;
+	vopdquant = &slice->vopdquant;
+	metadata = &slice->metadata;
+
+	second_field = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_SECOND_FIELD);
+	top_field_first = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TFF);
+	interlaced = picture->fcm != VC1_FCM_PROGRESSIVE;
+	ref_field = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_REFFIELD);
+	rangeredfrm = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RANGEREDFRM);
+	pq = cedrus_vc1_get_pq(picture->pqindex, entrypoint->quantizer);
+	flag = picture->intcompfield < 2 && picture->mvmode == VC1_MVMODE_INTENSITY_COMP;
+
+	out_buf = vb2_to_cedrus_buffer(&run->dst->vb2_buf);
+	out_buf->codec.vc1.rangeredfrm = rangeredfrm;
+	out_buf->codec.vc1.interlaced = interlaced;
+	out_buf->codec.vc1.ptype = picture->ptype;
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+
+	forward_vb2 = vb2_find_buffer(vq, slice->forward_ref_ts);
+	//forward_vb2 = vb2_find_buffer(vq, slice->backward_ref_ts);
+	//fwd_buf = NULL;
+	if (forward_vb2)
+		fwd_buf = vb2_to_cedrus_buffer(forward_vb2);
+	else
+		fwd_buf = out_buf;
+
+	backward_vb2 = vb2_find_buffer(vq, slice->backward_ref_ts);
+	//backward_vb2 = vb2_find_buffer(vq, slice->forward_ref_ts);
+	//bwd_buf = NULL;
+	if (backward_vb2)
+		bwd_buf = vb2_to_cedrus_buffer(backward_vb2);
+	else
+		bwd_buf = out_buf;
+
+	cedrus_engine_enable(ctx);
+
+	/* Set bitstream source */
+
+	slice_bytes = vb2_get_plane_payload(src_buf, 0);
+	cedrus_write(dev, VE_DEC_VC1_BITS_LEN, slice_bytes * 8);
+	cedrus_write(dev, VE_DEC_VC1_BITS_OFFSET, 0);
+
+	src_buf_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);
+	cedrus_write(dev, VE_DEC_VC1_BITS_END_ADDR,
+		     src_buf_addr + slice_bytes);
+	cedrus_write(dev, VE_DEC_VC1_BITS_ADDR,
+		     VE_DEC_VC1_BITS_ADDR_BASE(src_buf_addr) |
+		     VE_DEC_VC1_BITS_ADDR_VALID_SLICE_DATA |
+		     VE_DEC_VC1_BITS_ADDR_LAST_SLICE_DATA |
+		     VE_DEC_VC1_BITS_ADDR_FIRST_SLICE_DATA);
+
+	/* Set auxiliary buffers */
+
+	cedrus_write(dev, VE_DEC_VC1_DCACPRED_ADDR,
+		     ctx->codec.vc1.acdc_buf_addr);
+	cedrus_write(dev, VE_DEC_VC1_BITPLANE_ADDR,
+		     ctx->codec.vc1.bitplanes_buf_addr);
+	cedrus_write(dev, VE_DEC_VC1_MVINFO_ADDR,
+		     ctx->codec.vc1.mv_buf_addr);
+
+	cedrus_write(dev, VE_DEC_VC1_STATUS,
+		     VE_DEC_VC1_STATUS_INT_MASK);
+
+	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+		     VE_DEC_VC1_TRIGGER_TYPE_INIT_SWDEC);
+
+	/* TODO: minimize time impact of this block */
+	for (reg = 0; reg < slice->data_bit_offset; reg++) {
+		cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+				VE_DEC_VC1_TRIGGER_TYPE_GET_BITS |
+				VE_DEC_VC1_TRIGGER_TYPE_N_BITS(1));
+
+		cedrus_wait_for(dev, VE_DEC_VC1_STATUS, VE_DEC_VC1_STATUS_BITS_BUSY);
+	}
+
+	cedrus_write(dev, VE_DEC_VC1_ROT_CTRL, 0);
+
+	cedrus_write(dev, VE_DEC_VC1_PICHDRLEN,
+		     VE_DEC_VC1_PICHDRLEN_LENGTH(0));
+
+	reg = VE_DEC_VC1_EPHS_PROFILE(sequence->profile);
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_LOOPFILTER)
+		reg |= VE_DEC_VC1_EPHS_LOOPFILTER;
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_MULTIRES)
+		reg |= VE_DEC_VC1_EPHS_MULTIRES;
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_FASTUVMC)
+		reg |= VE_DEC_VC1_EPHS_FASTUVMC;
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_DMV)
+		reg |= VE_DEC_VC1_EPHS_EXTENDEDMV;
+	reg |= VE_DEC_VC1_EPHS_DQUANT(entrypoint->dquant);
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_VSTRANSFORM)
+		reg |= VE_DEC_VC1_EPHS_VSTRANSFORM;
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_OVERLAP)
+		reg |= VE_DEC_VC1_EPHS_OVERLAP;
+	reg |= VE_DEC_VC1_EPHS_QUANTIZER(entrypoint->quantizer);
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_RANGERED)
+		reg |= VE_DEC_VC1_EPHS_RANGERED;
+	if (sequence->flags & V4L2_VC1_SEQUENCE_FLAG_FINTERPFLAG)
+		reg |= VE_DEC_VC1_EPHS_FINTERPFLAG;
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_SYNCMARKER)
+		reg |= VE_DEC_VC1_EPHS_SYNCMARKER;
+	if (sequence->profile != VC1_PROFILE_ADVANCED)
+		reg |= VE_DEC_VC1_EPHS_EPTB_DET_BYPASS;
+	cedrus_write(dev, VE_DEC_VC1_EPHS, reg);
+	
+	if (sequence->profile == VC1_PROFILE_ADVANCED)
+		condover = picture->condover;
+	else if (picture->ptype == VC1_PICTURE_TYPE_B || pq < 9 ||
+		 !(entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_OVERLAP))
+		condover = VC1_CONDOVER_NONE;
+	else
+		condover = VC1_CONDOVER_ALL;
+
+	reg = VE_DEC_VC1_PICCTRL_PTYPE(picture->ptype);
+        reg |= VE_DEC_VC1_PICCTRL_FCM(picture->fcm ? picture->fcm + 1 : 0);
+	if (interlaced && !(top_field_first ^ second_field))
+		reg |= VE_DEC_VC1_PICCTRL_BOTTOM_FIELD;
+	if (second_field)
+		reg |= VE_DEC_VC1_PICCTRL_SECOND_FIELD;
+	if (rangeredfrm)
+		reg |= VE_DEC_VC1_PICCTRL_RANGEREDFRM;
+	if (fwd_buf && fwd_buf->codec.vc1.rangeredfrm)
+		reg |= VE_DEC_VC1_PICCTRL_FWD_RANGEREDFRM;
+	if (bwd_buf && bwd_buf->codec.vc1.rangeredfrm)
+		reg |= VE_DEC_VC1_PICCTRL_BWD_RANGEREDFRM;
+	reg |= VE_DEC_VC1_PICCTRL_TRANSACFRM(picture->transacfrm);
+	reg |= VE_DEC_VC1_PICCTRL_TRANSACFRM2(picture->transacfrm2);
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TRANSDCTAB)
+		reg |= VE_DEC_VC1_PICCTRL_TRANSDCTAB;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RNDCTRL)
+		reg |= VE_DEC_VC1_PICCTRL_RNDCTRL;
+	reg |= VE_DEC_VC1_PICCTRL_CONDOVER(condover ? condover + 1 : 0);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_ACPRED)
+		reg |= VE_DEC_VC1_PICCTRL_ACPRED_RAW;
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_OVERFLAGS)
+		reg |= VE_DEC_VC1_PICCTRL_OVERFLAGS_RAW;
+	reg |= VE_DEC_VC1_PICCTRL_CBPTAB(picture->cbptab);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_SKIPMB)
+		reg |= VE_DEC_VC1_PICCTRL_SKIPMB_RAW;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TTMBF)
+		reg |= VE_DEC_VC1_PICCTRL_TTMBF;
+	reg |= VE_DEC_VC1_PICCTRL_TTFRM(picture->ttfrm);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_DIRECTMB)
+		reg |= VE_DEC_VC1_PICCTRL_DIRECTMB_RAW;
+	if (bwd_buf && bwd_buf->codec.vc1.ptype != VC1_PICTURE_TYPE_P)
+	//if (picture->ptype != VC1_PICTURE_TYPE_P)
+		reg |= VE_DEC_VC1_PICCTRL_DIRECT_REF_INTRA;
+	if (bitplanes->bitplane_flags)
+		reg |= VE_DEC_VC1_PICCTRL_BITPL_CODING;
+	cedrus_write(dev, VE_DEC_VC1_PICCTRL, reg);
+
+	reg = VE_DEC_VC1_PICQP_PQINDEX(picture->pqindex);
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_HALFQP)
+		reg |= VE_DEC_VC1_PICQP_HALFQP;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_PQUANTIZER)
+		reg |= VE_DEC_VC1_PICQP_PQUANTIZER;
+	reg |= VE_DEC_VC1_PICQP_DQPPROFILE(vopdquant->dqprofile);
+	reg |= VE_DEC_VC1_PICQP_DQSBEDGE(vopdquant->dqsbedge);
+	reg |= VE_DEC_VC1_PICQP_DQDBEDGE(vopdquant->dqdbedge);
+	reg |= VE_DEC_VC1_PICQP_ALTPQUANT(vopdquant->altpquant);
+	if (vopdquant->flags & V4L2_VC1_VOPDQUANT_FLAG_DQUANTFRM)
+		reg |= VE_DEC_VC1_PICQP_DQUANTFRM;
+	if (vopdquant->flags & V4L2_VC1_VOPDQUANT_FLAG_DQBILEVEL)
+		reg |= VE_DEC_VC1_PICQP_DQBILEVEL;
+	cedrus_write(dev, VE_DEC_VC1_PICQP, reg);
+
+	bfraction = cedrus_vc1_get_fraction(picture->bfraction);
+	reg = VE_DEC_VC1_PICMV_BFRACTION(bfraction);
+	if (bfraction < FRACTION(1, 2))
+		reg |= VE_DEC_VC1_PICMV_BFRAC_LESS_THAN_HALF;
+	reg |= VE_DEC_VC1_PICMV_MVRANGE(picture->mvrange);
+	/* FIXME: is this ok? */
+	if (picture->ptype == VC1_PICTURE_TYPE_P &&
+	    picture->mvmode == VC1_MVMODE_INTENSITY_COMP)
+		mvmode = picture->mvmode2;
+	else
+		mvmode = picture->mvmode;
+	reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[mvmode & 3]);
+	//if ((picture->ptype == VC1_PICTURE_TYPE_B && fwd_buf && fwd_buf->codec.vc1.compen) ||
+	//    (picture->ptype != VC1_PICTURE_TYPE_B && picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP))
+	//if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP)
+	if (picture->ptype == VC1_PICTURE_TYPE_B) {
+		if (intenen)
+			reg |= VE_DEC_VC1_PICMV_INTENSITY_COMP_EN;
+	} else if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP) { // (flag) {
+		reg |= VE_DEC_VC1_PICMV_INTENSITY_COMP_EN;
+	}
+	if (picture->ptype == VC1_PICTURE_TYPE_P)
+		intenen = !!(reg & VE_DEC_VC1_PICMV_INTENSITY_COMP_EN);
+	else if (picture->ptype == VC1_PICTURE_TYPE_I)
+		intenen = 0;
+	reg |= VE_DEC_VC1_PICMV_MVTAB(picture->mvtab);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB)
+		reg |= VE_DEC_VC1_PICMV_MVTYPEMB_RAW;
+	cedrus_write(dev, VE_DEC_VC1_PICMV, reg);
+
+	if (picture->fcm == VC1_FCM_INTERLACED_FIELD) {
+		if (picture->ptype == VC1_PICTURE_TYPE_I) {
+			cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, 0);
+			cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x68, 0);
+			cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x6c, 0);
+			vc1_icb1_regbak = 0;
+			vc1_icb0_reg68 = 0;
+		} else if (picture->ptype == VC1_PICTURE_TYPE_B) {
+			cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, vc1_icb1_regbak & 0x3f3f3f3f);
+			cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x68, vc1_icb0_reg68);
+			if (second_field)
+				reg = 0;
+			else
+				reg = vc1_icf0_reg6c;
+			cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x6c, reg);
+		} else if (picture->ptype == VC1_PICTURE_TYPE_B) {
+			reg = VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(picture->lumscale);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT1(picture->lumshift);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASCALE2(picture->lumscale2);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(picture->lumshift2);
+			cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, reg);
+			if (!second_field) {
+				vc1_icf0_reg6c = vc1_icb1_regbak & 0xff3f3f3f;
+				cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x6c, vc1_icf0_reg6c);
+				cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x68, 0);
+				vc1_icb0_reg68 = reg | VE_DEC_VC1_PICINTENCOMP_FIELD(picture->intcompfield);
+			} else {
+				cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x6c, 0);
+				cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x68, vc1_icb0_reg68);
+				vc1_icf0_reg6c = vc1_icb1_regbak & 0xff3f3f3f;
+				vc1_icb1_regbak = reg | VE_DEC_VC1_PICINTENCOMP_FIELD(picture->intcompfield);
+			}
+		}
+	} else {
+		if (picture->ptype == VC1_PICTURE_TYPE_I) {
+			reg = 0;
+		} else if (picture->ptype == VC1_PICTURE_TYPE_P) {
+			reg = VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(picture->lumscale);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT1(picture->lumshift);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASCALE2(picture->lumscale2);
+			reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(picture->lumshift2);
+			if (!reg && oldval)
+				reg = oldval;
+			else
+				oldval = reg;
+		} else {
+			reg = oldval;
+		}
+		cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, reg);
+	}
+
+	if (picture->ptype == VC1_PICTURE_TYPE_B) {
+		frfd = (bfraction * picture->refdist) >> 8;
+		brfd = picture->refdist - frfd - 1;
+	} else {
+		frfd = picture->refdist;
+		brfd = 0;
+	}
+
+	if (frfd > 3)
+		frfd = 3;
+	if (brfd < 0)
+		brfd = 0;
+	else if (brfd > 3)
+		brfd = 3;
+
+	reg = 0;
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_FIELDTX)
+		reg |= VE_DEC_VC1_PICINTERLACE_FIELDTX_RAW;
+	//reg |= VE_DEC_VC1_PICINTERLACE_DMVRANGE(vc1_dmvrange_map[picture->dmvrange & 3]);
+	reg |= VE_DEC_VC1_PICINTERLACE_DMVRANGE(picture->dmvrange);
+	//if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_4MVSWITCH)
+	if (mvmode == VC1_MVMODE_1MV)
+	//if (picture->mvmode == VC1_MVMODE_1MV)
+		reg |= VE_DEC_VC1_PICINTERLACE_4MVSWITCH;
+	reg |= VE_DEC_VC1_PICINTERLACE_MBMODETAB(picture->mbmodetab);
+	reg |= VE_DEC_VC1_PICINTERLACE_IMVTAB(picture->imvtab);
+	reg |= VE_DEC_VC1_PICINTERLACE_ICBPTAB(picture->icbptab);
+	if (flag)//(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP)
+		reg |= VE_DEC_VC1_PICINTERLACE_INTENCOMP;
+	reg |= VE_DEC_VC1_PICINTERLACE_2MVBPTAB(picture->twomvbptab);
+	reg |= VE_DEC_VC1_PICINTERLACE_4MVBPTAB(picture->fourmvbptab);
+	reg |= VE_DEC_VC1_PICINTERLACE_FRFD(frfd);
+	reg |= VE_DEC_VC1_PICINTERLACE_BRFD(brfd);
+	if (!(second_field ^ ref_field))
+		reg |= VE_DEC_VC1_PICINTERLACE_REFFIELD;
+	reg |= VE_DEC_VC1_PICINTERLACE_INTENCOMPFLD(picture->intcompfield);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_FORWARDMB)
+		reg |= VE_DEC_VC1_PICINTERLACE_FORWARD_RAW;
+	if (fwd_buf && bwd_buf) {
+		if (fwd_buf->codec.vc1.interlaced)
+			reg |= VE_DEC_VC1_PICINTERLACE_FWD_INTERLACE;
+		if (bwd_buf->codec.vc1.interlaced)
+			reg |= VE_DEC_VC1_PICINTERLACE_BWD_INTERLACE;
+	} else if (interlaced) {
+		reg |= VE_DEC_VC1_PICINTERLACE_FWD_INTERLACE |
+		       VE_DEC_VC1_PICINTERLACE_BWD_INTERLACE;
+	}
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_NUMREF)
+		reg |= VE_DEC_VC1_PICINTERLACE_NUMREF;
+	cedrus_write(dev, VE_DEC_VC1_PICINTERLACE, reg);
+
+	/* Set frame dimensions. */
+
+	reg = VE_DEC_VC1_FSIZE_WIDTH(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_FSIZE_HEIGHT(ctx->src_fmt.height);
+	cedrus_write(dev, VE_DEC_VC1_FSIZE, reg);
+
+	reg = VE_DEC_VC1_PICSIZE_WIDTH(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_PICSIZE_HEIGHT(ctx->src_fmt.height);
+	cedrus_write(dev, VE_DEC_VC1_PICSIZE, reg);
+
+	cedrus_write(dev, VE_ENGINE_DEC_VC1 + 0x70, 0);
+
+	/* Destination luma and chroma buffers. */
+
+	dst_luma_addr = cedrus_dst_buf_addr(ctx, &run->dst->vb2_buf, 0);
+	dst_chroma_addr = cedrus_dst_buf_addr(ctx, &run->dst->vb2_buf, 1);
+
+	cedrus_write(dev, VE_DEC_VC1_REC_LUMA, dst_luma_addr);
+	cedrus_write(dev, VE_DEC_VC1_REC_CHROMA, dst_chroma_addr);
+
+	/* Forward and backward prediction reference buffers. */
+
+	if (forward_vb2) {
+		cedrus_write(dev, VE_DEC_VC1_FWD_REF_LUMA_ADDR,
+			cedrus_dst_buf_addr(ctx, forward_vb2, 0));
+		cedrus_write(dev, VE_DEC_VC1_FWD_REF_CHROMA_ADDR,
+			cedrus_dst_buf_addr(ctx, forward_vb2, 1));
+	} else {
+		cedrus_write(dev, VE_DEC_VC1_FWD_REF_LUMA_ADDR, dst_luma_addr);
+		cedrus_write(dev, VE_DEC_VC1_FWD_REF_CHROMA_ADDR, dst_chroma_addr);
+	}
+
+	if (backward_vb2) {
+		cedrus_write(dev, VE_DEC_VC1_BWD_REF_LUMA_ADDR,
+			cedrus_dst_buf_addr(ctx, backward_vb2, 0));
+		cedrus_write(dev, VE_DEC_VC1_BWD_REF_CHROMA_ADDR,
+			cedrus_dst_buf_addr(ctx, backward_vb2, 1));
+	} else {
+		cedrus_write(dev, VE_DEC_VC1_BWD_REF_LUMA_ADDR, dst_luma_addr);
+		cedrus_write(dev, VE_DEC_VC1_BWD_REF_CHROMA_ADDR, dst_chroma_addr);
+	}
+
+	/* Setup bitplanes */
+
+	if (bitplanes && bitplanes->bitplane_flags)
+		cedrus_vc1_bitplanes_setup(ctx, run);
+
+	reg = VE_DEC_VC1_CTRL_FINISH_IRQ_EN |
+	      VE_DEC_VC1_CTRL_ERROR_IRQ_EN |
+	      VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN;
+	if (picture->ptype == VC1_PICTURE_TYPE_SKIPPED) {
+		printk("frame is skipped!\n");
+		reg |= VE_DEC_VC1_CTRL_NO_RECONSTRUCT_PIC;
+	}
+	cedrus_write(dev, VE_DEC_VC1_CTRL, reg);
+
+	return 0;
+}
+
+static struct file *f;
+static loff_t offset;
+
+static int cedrus_vc1_start(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	int ret;
+	
+	oldval = 0;
+	intenen = false;
+	vc1_icb1_regbak = vc1_icb0_reg68 = vc1_icf0_reg6c = 0;
+	seq = 0;
+	
+	f = filp_open("/root/out.bin", O_CREAT | O_WRONLY | O_TRUNC, 0666);
+	offset = 0;
+
+	ctx->codec.vc1.mv_buf =
+		dma_alloc_coherent(dev->dev, MV_BUF_SIZE,
+				   &ctx->codec.vc1.mv_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.mv_buf)
+		return -ENOMEM;
+
+	ctx->codec.vc1.acdc_buf =
+		dma_alloc_coherent(dev->dev, ACDC_BUF_SIZE,
+				   &ctx->codec.vc1.acdc_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.acdc_buf) {
+		ret = -ENOMEM;
+		goto err_mv_buf;
+	}
+
+	ctx->codec.vc1.bitplanes_buf =
+		dma_alloc_coherent(dev->dev, BITPLANES_BUF_SIZE,
+				   &ctx->codec.vc1.bitplanes_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.bitplanes_buf) {
+		ret = -ENOMEM;
+		goto err_acdc_buf;
+	}
+
+	return 0;
+
+err_acdc_buf:
+	dma_free_coherent(dev->dev, ACDC_BUF_SIZE,
+			  ctx->codec.vc1.acdc_buf,
+			  ctx->codec.vc1.acdc_buf_addr);
+
+err_mv_buf:
+	dma_free_coherent(dev->dev, MV_BUF_SIZE,
+			  ctx->codec.vc1.mv_buf,
+			  ctx->codec.vc1.mv_buf_addr);
+
+	return ret;
+}
+
+#include <linux/kernel.h>
+
+static void write_section(const char *info, volatile char *regs, unsigned int o, unsigned int size)
+{
+	char data[128];
+	int i;
+
+	for (i = 0; i <= size; i += 4) {
+		snprintf(data, sizeof(data), "%.3x: %.8x\n", i + o, readl(regs + i + o));
+		kernel_write(f, data, strlen(data), &offset);
+	}
+	kernel_write(f, info, strlen(info), &offset);
+}
+
+static void cedrus_vc1_stop(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	
+	filp_close(f, NULL);
+
+	dma_free_coherent(dev->dev, MV_BUF_SIZE,
+			  ctx->codec.vc1.mv_buf,
+			  ctx->codec.vc1.mv_buf_addr);
+	dma_free_coherent(dev->dev, ACDC_BUF_SIZE,
+			  ctx->codec.vc1.acdc_buf,
+			  ctx->codec.vc1.acdc_buf_addr);
+	dma_free_coherent(dev->dev, BITPLANES_BUF_SIZE,
+			  ctx->codec.vc1.bitplanes_buf,
+			  ctx->codec.vc1.bitplanes_buf_addr);
+}
+
+static void cedrus_vc1_trigger(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	/*int i;
+
+	for (i = 0; i <= 0xec; i+=4)
+		printk("%.3x: %.8x\n", i, cedrus_read(dev, i));
+	printk("main section\n");
+	for (i = 0x300; i <= 0x3cc; i+=4)
+		printk("%.3x: %.8x\n", i, cedrus_read(dev, i));
+	printk("--eof--\n");*/
+	
+	//write_section("main section\n", dev->base, 0, 0xec);
+	//write_section("--eof--\n", dev->base, 0x300, 0xcc);
+	if (seq == 59)
+		kernel_write(f, ctx->codec.vc1.bitplanes_buf, BITPLANES_BUF_SIZE, &offset);
+	
+	seq++;
+
+	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+		     VE_DEC_VC1_TRIGGER_TYPE_DECODE);
+}
+
+struct cedrus_dec_ops cedrus_dec_ops_vc1 = {
+	.irq_clear	= cedrus_vc1_irq_clear,
+	.irq_disable	= cedrus_vc1_irq_disable,
+	.irq_status	= cedrus_vc1_irq_status,
+	.setup		= cedrus_vc1_setup,
+	.start		= cedrus_vc1_start,
+	.stop		= cedrus_vc1_stop,
+	.trigger	= cedrus_vc1_trigger,
+};
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_video.c linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_video.c
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_video.c	2022-11-30 21:46:32.466627429 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/cedrus_video.c	2022-12-02 10:32:05.366600075 +0100
@@ -56,6 +56,11 @@
 		.capabilities	= CEDRUS_CAPABILITY_VP8_DEC,
 	},
 	{
+		.pixelformat	= V4L2_PIX_FMT_VC1_SLICE,
+		.directions	= CEDRUS_DECODE_SRC,
+		.capabilities	= CEDRUS_CAPABILITY_VC1_DEC,
+	},
+	{
 		.pixelformat	= V4L2_PIX_FMT_NV12,
 		.directions	= CEDRUS_DECODE_DST,
 		.capabilities	= CEDRUS_CAPABILITY_UNTILED,
@@ -118,6 +123,7 @@
 	case V4L2_PIX_FMT_H264_SLICE:
 	case V4L2_PIX_FMT_HEVC_SLICE:
 	case V4L2_PIX_FMT_VP8_FRAME:
+	case V4L2_PIX_FMT_VC1_SLICE:
 		/* Zero bytes per line for encoded source. */
 		bytesperline = 0;
 		/* Choose some minimum size since this can't be 0 */
@@ -330,6 +336,7 @@
 	switch (ctx->src_fmt.pixelformat) {
 	case V4L2_PIX_FMT_H264_SLICE:
 	case V4L2_PIX_FMT_HEVC_SLICE:
+	case V4L2_PIX_FMT_VC1_SLICE:
 		vq->subsystem_flags |=
 			VB2_V4L2_FL_SUPPORTS_M2M_HOLD_CAPTURE_BUF;
 		break;
@@ -352,6 +359,9 @@
 	case V4L2_PIX_FMT_VP8_FRAME:
 		ctx->current_codec = &cedrus_dec_ops_vp8;
 		break;
+	case V4L2_PIX_FMT_VC1_SLICE:
+		ctx->current_codec = &cedrus_dec_ops_vc1;
+		break;
 	}
 
 	/* Propagate format information to capture. */
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/Makefile linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/Makefile
--- linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/Makefile	2022-11-27 22:31:48.000000000 +0100
+++ linux-6.1-rc7/drivers/staging/media/sunxi/cedrus/Makefile	2022-11-30 21:45:13.033295530 +0100
@@ -3,4 +3,4 @@
 
 sunxi-cedrus-y = cedrus.o cedrus_video.o cedrus_hw.o cedrus_dec.o \
 		 cedrus_mpeg2.o cedrus_h264.o cedrus_h265.o \
-		 cedrus_vp8.o
+		 cedrus_vp8.o cedrus_vc1.o
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/include/media/v4l2-ctrls.h linux-6.1-rc7/include/media/v4l2-ctrls.h
--- linux-6.1-rc7/include/media/v4l2-ctrls.h	2022-11-27 22:31:48.000000000 +0100
+++ linux-6.1-rc7/include/media/v4l2-ctrls.h	2022-11-30 21:45:07.156628969 +0100
@@ -13,6 +13,12 @@
 #include <linux/videodev2.h>
 #include <media/media-request.h>
 
+/*
+ * Include the stateless codec compound control definitions.
+ * This will move to the public headers once this API is fully stable.
+ */
+#include <media/vc1-ctrls.h>
+
 /* forward references */
 struct file;
 struct poll_table_struct;
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/include/media/vc1-ctrls.h linux-6.1-rc7/include/media/vc1-ctrls.h
--- linux-6.1-rc7/include/media/vc1-ctrls.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.1-rc7/include/media/vc1-ctrls.h	2022-12-02 10:32:05.366600075 +0100
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * These are the VC1 state controls for use with stateless VC1 codec drivers.
+ *
+ * It turns out that these structs are not stable yet and will undergo
+ * more changes. So keep them private until they are stable and ready to
+ * become part of the official public API.
+ */
+
+#ifndef _VC1_CTRLS_H_
+#define _VC1_CTRLS_H_
+
+/* Our pixel format isn't stable at the moment */
+#define V4L2_PIX_FMT_VC1_SLICE v4l2_fourcc('S', 'V', 'C', '1') /* VC1 parsed slices */
+
+#define V4L2_CID_STATELESS_VC1_SLICE_PARAMS	(V4L2_CID_CODEC_STATELESS_BASE + 600)
+#define V4L2_CID_STATELESS_VC1_BITPLANES	(V4L2_CID_CODEC_STATELESS_BASE + 601)
+
+/* enum v4l2_ctrl_type type values */
+#define V4L2_CTRL_TYPE_VC1_SLICE_PARAMS			0x0109
+#define	V4L2_CTRL_TYPE_VC1_BITPLANES			0x010a
+
+#define V4L2_VC1_SEQUENCE_FLAG_PULLDOWN			0x01
+#define V4L2_VC1_SEQUENCE_FLAG_INTERLACE		0x02
+#define V4L2_VC1_SEQUENCE_FLAG_TFCNTRFLAG		0x04
+#define V4L2_VC1_SEQUENCE_FLAG_FINTERPFLAG		0x08
+#define V4L2_VC1_SEQUENCE_FLAG_PSF			0x10
+
+struct v4l2_vc1_sequence {
+	__u8	profile;
+	__u8	level;
+	__u8	colordiff_format;
+	__u32	flags;
+};
+
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_BROKEN_LINK	0x001
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_CLOSED_ENTRY	0x002
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_PANSCAN		0x004
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_REFDIST		0x008
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_LOOPFILTER	0x010
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_FASTUVMC	0x020
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_MV	0x040
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_VSTRANSFORM	0x080
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_OVERLAP		0x100
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_DMV	0x200
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_RANGE_MAPY	0x400
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_RANGE_MAPUV	0x800
+
+struct v4l2_vc1_entrypoint_header {
+	__u8	dquant;
+	__u8	quantizer;
+	__u16	coded_width;
+	__u16	coded_height;
+	__u8	range_mapy;
+	__u8	range_mapuv;
+	__u32	flags;
+};
+
+#define V4L2_VC1_PICTURE_LAYER_FLAG_RANGEREDFRM		0x0001
+#define V4L2_VC1_PICTURE_LAYER_FLAG_HALFQP		0x0002
+#define V4L2_VC1_PICTURE_LAYER_FLAG_PQUANTIZER		0x0004
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TRANSDCTAB		0x0008
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TFF			0x0010
+#define V4L2_VC1_PICTURE_LAYER_FLAG_RNDCTRL		0x0020
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TTMBF		0x0040
+#define V4L2_VC1_PICTURE_LAYER_FLAG_4MVSWITCH		0x0080
+#define V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP		0x0100
+#define V4L2_VC1_PICTURE_LAYER_FLAG_NUMREF		0x0200
+#define V4L2_VC1_PICTURE_LAYER_FLAG_REFFIELD		0x0400
+#define V4L2_VC1_PICTURE_LAYER_FLAG_SECOND_FIELD	0x0800
+
+struct v4l2_vc1_picture_layer {
+	__u8	ptype;
+	__u8	pqindex;
+	__u8	mvrange;
+	__u8	respic;
+	__u8	transacfrm;
+	__u8	transacfrm2;
+	__u8	bfraction;
+	__u8	fcm;
+	__u8	mvmode;
+	__u8	mvmode2;
+	__u8	lumscale;
+	__u8	lumshift;
+	__u8	lumscale2;
+	__u8	lumshift2;
+	__u8	mvtab;
+	__u8	cbptab;
+	__u8	intcompfield;
+	__u8	dmvrange;
+	__u8	mbmodetab;
+	__u8	twomvbptab;
+	__u8	fourmvbptab;
+	__u8	ttfrm;
+	__u8	refdist;
+	__u8	condover;
+	__u8	imvtab;
+	__u8	icbptab;
+	__u32	flags;
+};
+
+#define V4L2_VC1_VOPDQUANT_FLAG_DQUANTFRM		0x1
+#define V4L2_VC1_VOPDQUANT_FLAG_DQBILEVEL		0x2
+
+struct v4l2_vc1_vopdquant {
+	__u8	altpquant;
+	__u8	dqprofile;
+	__u8	dqsbedge;
+	__u8	dqdbedge;
+	__u8	flags;
+};
+
+#define V4L2_VC1_METADATA_FLAG_MULTIRES		0x1
+#define V4L2_VC1_METADATA_FLAG_SYNCMARKER	0x2
+#define V4L2_VC1_METADATA_FLAG_RANGERED		0x4
+
+struct v4l2_vc1_metadata {
+	__u8	maxbframes;
+	__u8	flags;
+};
+
+#define V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB	0x01
+#define V4L2_VC1_RAW_CODING_FLAG_DIRECTMB	0x02
+#define V4L2_VC1_RAW_CODING_FLAG_SKIPMB		0x04
+#define V4L2_VC1_RAW_CODING_FLAG_FIELDTX	0x08
+#define V4L2_VC1_RAW_CODING_FLAG_FORWARDMB	0x10
+#define V4L2_VC1_RAW_CODING_FLAG_ACPRED		0x20
+#define V4L2_VC1_RAW_CODING_FLAG_OVERFLAGS	0x40
+
+struct v4l2_ctrl_vc1_slice_params {
+	__u32	bit_size;
+	__u32	data_bit_offset;
+	__u64	backward_ref_ts;
+	__u64	forward_ref_ts;
+
+	struct v4l2_vc1_sequence sequence;
+	struct v4l2_vc1_entrypoint_header entrypoint_header;
+	struct v4l2_vc1_picture_layer picture_layer;
+	struct v4l2_vc1_vopdquant vopdquant;
+	struct v4l2_vc1_metadata metadata;
+
+	__u8	raw_coding_flags;
+};
+
+#define V4L2_VC1_BITPLANE_FLAG_MVTYPEMB		0x01
+#define V4L2_VC1_BITPLANE_FLAG_DIRECTMB		0x02
+#define V4L2_VC1_BITPLANE_FLAG_SKIPMB		0x04
+#define V4L2_VC1_BITPLANE_FLAG_FIELDTX		0x08
+#define V4L2_VC1_BITPLANE_FLAG_FORWARDMB	0x10
+#define V4L2_VC1_BITPLANE_FLAG_ACPRED		0x20
+#define V4L2_VC1_BITPLANE_FLAG_OVERFLAGS	0x40
+
+struct v4l2_ctrl_vc1_bitplanes {
+	__u8	bitplane_flags;
+
+	__u8	mvtypemb[2048];
+	__u8	directmb[2048];
+	__u8	skipmb[2048];
+	__u8	fieldtx[2048];
+	__u8	forwardmb[2048];
+	__u8	acpred[2048];
+	__u8	overflags[2048];
+};
+
+#endif
diff --speed-large-files --no-dereference --minimal -Naur linux-6.1-rc7/include/uapi/linux/videodev2.h linux-6.1-rc7/include/uapi/linux/videodev2.h
--- linux-6.1-rc7/include/uapi/linux/videodev2.h	2022-11-30 21:46:34.426627394 +0100
+++ linux-6.1-rc7/include/uapi/linux/videodev2.h	2022-12-02 12:13:11.596490670 +0100
@@ -731,6 +731,7 @@
 #define V4L2_PIX_FMT_XVID     v4l2_fourcc('X', 'V', 'I', 'D') /* Xvid           */
 #define V4L2_PIX_FMT_VC1_ANNEX_G v4l2_fourcc('V', 'C', '1', 'G') /* SMPTE 421M Annex G compliant stream */
 #define V4L2_PIX_FMT_VC1_ANNEX_L v4l2_fourcc('V', 'C', '1', 'L') /* SMPTE 421M Annex L compliant stream */
+#define V4L2_PIX_FMT_VC1_SLICE v4l2_fourcc('S', 'V', 'C', '1') /* VC1 parsed slices */
 #define V4L2_PIX_FMT_VP8      v4l2_fourcc('V', 'P', '8', '0') /* VP8 */
 #define V4L2_PIX_FMT_VP8_FRAME v4l2_fourcc('V', 'P', '8', 'F') /* VP8 parsed frame */
 #define V4L2_PIX_FMT_VP9      v4l2_fourcc('V', 'P', '9', '0') /* VP9 */
